import subprocess
import AnalocUtils
import xml.etree.ElementTree as ET
import argparse
import logging
import time
import re
import os.path as PATH
import os
import zipfile

def updateAnalocSystemScripts(newScriptsFetchUrl, newVersionNumber):
    supportedCompressionTypes = ['.zip']
    
    # Gets the file name without the path (file name + file extention)
    baseName = PATH.basename(newScriptsFetchUrl)
    filenameParts = PATH.splitext(baseName)
    fileType = filenameParts[1]

    # Checks if the file type is supported
    if (not fileType in supportedCompressionTypes):
        error = 'File type: \'' + fileType + '\' to download is not supported. The supported file types are: ' + \
                str(supportedCompressionTypes).replace('[', '').replace(']', '')
        return False, error
    else:
        currentVersion = int(AnalocUtils.readConfigValue('version-number'))

        # Checks if the current version is the same as the new one
        if (currentVersion == newVersionNumber):
            error = 'The current scripts version is: ' + str(currentVersion) + '. The new version must be diffrent than the current version.'
            return False, error
        else:
            # Preparing the output file flag
            downloadDirectoryPath = AnalocUtils.readConfigValue('software-default-directory')
            
            # Checks if the directory doesn't exists
            if not PATH.exists(downloadDirectoryPath):
                os.mkdir(downloadDirectoryPath)
            
            newFileName = 'v' + str(newVersionNumber) + fileType
            downloadedFilePath = PATH.join(downloadDirectoryPath, newFileName)
            
            AnalocUtils.printDebug('Downloading url: ' + newScriptsFetchUrl)
            
            if filenameParts[0] != 'v' + str(newVersionNumber):
                error = 'The directory of the scripts: \'' + filenameParts[0] + '\' must be: \'' + 'v' + str(newVersionNumber) + '\''
                return False, error
            
            errorDownload = __downloadUrl(newScriptsFetchUrl, downloadedFilePath)
            
            # Checks if the download went well
            if (errorDownload is not None):
                error = 'Unable to download the file url: ' + newScriptsFetchUrl + '. Error: ' + errorDownload
                __CheckAndDeleteDownloadFile(downloadedFilePath)
                return False, error
            
            AnalocUtils.printDebug('Finished download')
            AnalocUtils.printDebug('Start unzipping file: ' + downloadedFilePath)
            
            errorUnCompress = __unCompressFile(downloadedFilePath, fileType, downloadDirectoryPath)
            
            # Checks if we sucesseded to uncompress the file
            if (errorUnCompress is not None):
                error = 'Unable to un compress the file url: ' + newScriptsFetchUrl + '. Error: ' + errorUnCompress
                __CheckAndDeleteDownloadFile(downloadedFilePath)
                return False, error
            
            AnalocUtils.printDebug('Finished unzipping')
            AnalocUtils.printDebug('Starting to delete zip file: ' + downloadedFilePath)
            
            # Delete the compressed file
            if (not AnalocUtils.deleteFile('AnalocCommands-updateAnalocSystemScripts', downloadedFilePath)):
                error = 'Unable to delete the compressed file after uncompressing it.'
                return False, error
            
            AnalocUtils.printDebug('Finished delete zip file')
            
            # Moving the new scripts directory
            unCompressedDirectoryPath = PATH.join(downloadDirectoryPath, PATH.splitext(newFileName)[0])
            
            AnalocUtils.printDebug('Start updating config file')
            
            if (not AnalocUtils.updateConfigValue('version-number', newVersionNumber)):
                error = 'Unable to update the config file with the new version number'
                __CheckAndDeleteDownloadFile(unCompressedDirectoryPath, True)
                return False, error
            else:
                AnalocUtils.printDebug('Finish update config file')
                return True, ''

def __downloadUrl(url, pathToSaveFile):
    try:
        os.environ['PATH'] += os.pathsep + '/usr/bin/'
        outputFlag = '--output-document=\"' + pathToSaveFile + '\"'
        cmd = 'sudo wget ' + url + ' ' + outputFlag
        procWgetFile = subprocess.Popen(cmd, stderr=subprocess.PIPE, shell=True)
        procWgetFile.wait()
        
        # Checks if the e completed the download
        if (procWgetFile.returncode != 0):
            error = str(procWgetFile.stderr.read())
            return error
    # handle errors
    except BaseException as err:
        return "General Error:" + str(err)
    else:
        return None

def __unCompressFile(file_path, file_type, extractToDirectory):
    try:
        if file_type == '.zip':
            with zipfile.ZipFile(file_path, 'r') as myzip:
                myzip.extractall(extractToDirectory)
        else:
            return 'UnSupported file type: ' + file_type
    except BaseException as err:
        return str(err)
    else:
        return None

def __CheckAndDeleteDownloadFile(file_path, is_directory=False):
    # Checks if the file exists
    if PATH.exists(file_path):
        if (not is_directory):
            return AnalocUtils.deleteFile('AnalocCommands-__CheckAndDeleteDownloadFile', file_path)
        else:
            return AnalocUtils.deleteDir('AnalocCommands-__CheckAndDeleteDownloadFile', file_path)
    return True

def getCurrentSoftwareVersion():
    version = AnalocUtils.readConfigValue('version-number')
    if (version != ''):
        return True, version
    else:
        return False, 'Unable to read current system version'

#=======================================================================================
# Method Description: The method runs a given unix command
# Parameters: command - The command to run
# Return Value: Boolean - if the operation went well or not
# Aditional Info: None.
#=======================================================================================
def runUnixCommand(command):
    try:
        cmd = command.split(' ')
        procUnixCommand = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        procUnixCommand.wait()
    except BaseException as err:
        error = 'Unable to run the unix command: \'' + command + '\'. Error: ' + str(err)
        return False, error
    else:
        if (procUnixCommand.returncode == 0):
            return_output = None
            
            # Checks if there is an output
            if (procUnixCommand.stdout is not None):
                return_output = str(procUnixCommand.stdout.read())
            return True, return_output
        else:
            error = 'Unable to run the unix command: \'' + command + '\'. Error: ' + str(procUnixCommand.stderr.read())
            return False, error

def __checkIfKeyIsValidXml(key):
    # .+\s.+ - contains whitespaces
    # xml* - starts with xml
    # [^a-zA-Z] - starts with char not a letter
    # [a-zA-Z]+[^a-zA-Z0-9_-] - contains charachter that is not: letter, digit, _, -
    reInValidPattern = ".+\s.+|xml*|[^a-zA-Z]|[a-zA-Z]+[^a-zA-Z0-9_-]"
    doesValidXmlKey = re.match(reInValidPattern, key) != None
    
    if(doesValidXmlKey):
        error = "Key: \'" + key + """\' does not match a valid xml key:
        1. Names can contain letters, numbers, and other characters('_' '-')
        2. Names cannot start with a number or punctuation character
        3. Names cannot start with the letters xml (or XML, or Xml, etc)
        4. Names cannot contain spaces"""
        return False, error
    
    return True, ''

#=======================================================================================
# Method Description: The method adds a new node to the config file.
# Parameters: key: The key of the node to add.
#             value: The value of the node
# Return Value: Boolean - if the operation went well or not.
# Aditional Info: If the key doesn't exists return False.
#=======================================================================================
def addNewConfigNode(key, value):
    strKey = str(key).lower()
    try:
        # Gets the xml tree
        tree = ET.parse(AnalocUtils.config_path)
    except BaseException as err:
        error = 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to parse the config xml file. Error: ' + str(err)
        return False, error
    else:
        doesKeyValid, error = __checkIfKeyIsValidXml(strKey)
        
        # Checks if the key is a valid xml key
        if (not doesKeyValid):
            return False, error
        else:    
            # Gets the root of the tree
            root = tree.getroot()
            
            try:
                elementToUpdate = root.find(strKey)
            
                # Checks if the key already exists.
                if (elementToUpdate is not None):
                    error = 'Line: ' + str(AnalocUtils.lineno()) + '. Key:\'' + strKey + '\' already exists.'
                    return False, error
                else:
                    # Creates the new node and sets its text
                    newNode = ET.SubElement(root, strKey)
                    newNode.text = str(value)
                    tree = ET.ElementTree(root)
                    with open(AnalocUtils.config_path, "w") as fh:
                        tree.write(fh)
            except BaseException as err:
                error = 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to update the config file. Error: ' + str(err)
                return False, error
            # All went well
            else:
                return True, None
        
#=======================================================================================
# Method Description: The method removes a node from the config file.
# Parameters: key: The key of the node to remove.
# Return Value: Boolean - if the operation went well or not.
# Aditional Info: If the key doesn't exists return False.
#=======================================================================================
def removeConfigNode(key):
    strKey = str(key).lower()
    try:
        # Gets the xml tree
        tree = ET.parse(AnalocUtils.config_path)
        
    except BaseException as err:
        error = 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to parse the config xml file. Error: ' + str(err)
        return False, error
    else:
        # Gets the root of the tree
        root = tree.getroot()
        
        elementToRemove = root.find(strKey)
        
        # Checks if the key doesn't exists
        if (elementToRemove is None):
            error = 'Line: ' + str(AnalocUtils.lineno()) + '. The key: ' + strKey + ' doesn\'t exists in the config file'
            return False, error
        else:
            try:
                root.remove(elementToRemove)
                tree = ET.ElementTree(root)
                with open(AnalocUtils.config_path, "w") as fh:
                    tree.write(fh)
            except BaseException as err:
                error = 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to update the config file. Error: ' + str(err)
                return False, error
            # All went well
            else:
                return True, None

#=======================================================================================
# Method Description: The method updates the value of a given node key.
# Parameters: key: The key of the node to update.
#             newValue: The new value to update to.
# Return Value: Boolean - if the operation went well or not.
# Aditional Info: If the key doesn't exists return False.
#=======================================================================================
def updateConfigValue(key, newValue):
    strKey = str(key).lower()
    try:
        # Gets the xml tree
        tree = ET.parse(AnalocUtils.config_path)
    except BaseException as err:
        error = 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to parse the config xml file. Error: ' + str(err)
        return False, error
    else:
        # Gets the root of the tree
        root = tree.getroot()
        
        elementToUpdate = root.find(strKey)
        
        # Checks if the key doesn't exists
        if (elementToUpdate is None):
            error = 'Line: ' + str(AnalocUtils.lineno()) + '. The key: ' + strKey + ' doesn\'t exists in the config file'
            return False, error
        else:
            try:
                elementToUpdate.text = str(newValue)
                tree = ET.ElementTree(root)
                with open(AnalocUtils.config_path, "w") as fh:
                    tree.write(fh)
            except BaseException as err:
                error = 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to update the config file. Error: ' + str(err)
                return False, error
            # All went well
            else:
                return True, None
                    
#=======================================================================================
# Method Description: The method updates the time on the machine using the ntpdate package.
# Parameters: None.
# Return Value: Boolean - if the operation went well
# Aditional Info: None.
#=======================================================================================
def updateNtpDate():
    print '\n==================================================='
    print 'Update date and time using the ntpdate package...'
    print '===================================================\n'
    
    try:
        pId = AnalocUtils.isProcessRunning('ntp')
        if (pId != -999):
            print 'Stoping ntp service..'
            cmd = ['sudo', 'service', 'ntp', 'stop']
            procStopNtp = subprocess.Popen(cmd)
            procStopNtp.wait()
            
            if (procStopNtp.returncode != 0):
                print 'Can\'t stop ntp service'
                return False
            
        print 'ntp service not running now..'
        print 'Updating time using ntpd..'
        
        # Set the time of the machine to the ntp time
        cmd = ['sudo', 'ntpd', '-q', '-x']
        procNtp = subprocess.Popen(cmd)
        time.sleep(20)
        returnCode = procNtp.poll()

        if (returnCode is None):
            print 'Ntp update TIMEOUT!!!'
            procNtp.kill()
            return False
        elif (returnCode != 0):
            print 'Can\'t update using ntpdate'
            AnalocUtils.writeLog(logging.ERROR, 'AnalocCommands-updateNtpDate', 'Unable to update the time using the ntpd -q package.')
            return False
        else:
            return True
    except BaseException as err:
        AnalocUtils.writeLog(logging.ERROR, 'AnalocCommands-updateNtpDate', 'Unable to update the time using the ntpd package. Error: ' + str(err))
        return False
    finally:
        print 'Starting back ntp service..'
        cmd = ['sudo', 'service', 'ntp', 'start']
        procStartNtp = subprocess.Popen(cmd)
        procStartNtp.wait()
        
def main():
    parser = argparse.ArgumentParser(description='Analoc commands')
    parser.add_argument('-c','--command', help='The command to execute. Commands: ntp', required=True)
    args = vars(parser.parse_args())

    # Checks if we got all the params needed
    if len(args) != 1:
        print 'incorrect number of arguments. expected 1, got:', str(len(args))
    elif args['command'] == "ntp":
        updateNtpDate()
    else:
        print 'No such command:', args['command']

if __name__ == "__main__":
    main()