import argparse
import AnalocSender
import AnalocUtils
import AnalocCommands
import threading
import os.path as PATH
import os
import datetime
import glob
import logging
import json

nthreadCounter = 1
lstThreads = []
STATE_FAILED = 2
STATE_EXECUTED = 1

class myThreadSetCommandState(threading.Thread):
    def __init__(self, threadID, threadName, lstData, sendurl, isSendingNormalData, backupStatesDirectory = '', currentFile = ''):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = threadName
        self.lstData = lstData
        self.currentFile = currentFile
        self.backupDirectory = backupStatesDirectory
        self.sendurl = sendurl
        self.isSendingNormalData = isSendingNormalData
    def run(self):
        print "Starting " + self.name
        
        # Sends the data
        allWentWell = AnalocSender.sendData(self.lstData, self.currentFile, self.sendurl)
        
        # If we need to do any more operations in case of sending data
        # We don't need to do anything if we are sending jsons right now.
        # And also only if the something went wrong
        if (self.isSendingNormalData and (not allWentWell)):
            # Creates the new file name
            fileNameWithNewExtention = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S") + '-' + str(self.threadID) + '.json'
            newAnalocFile = PATH.join(self.backupDirectory, PATH.basename(fileNameWithNewExtention))
            
            try:
                # Saves the data in a json file
                with open(newAnalocFile, 'w') as fsStream:
                    fsStream.write(json.dumps(self.lstData, separators=(',',':'), sort_keys=False))
            except BaseException as err:
                AnalocUtils.writeLog(logging.ERROR, 'RemoteControl-myThreadSetCommandState', 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to save the data in JSON format. Error: ' + str(err))
                
class myThreadJsonCommandState(threading.Thread):
    def __init__(self, threadID, threadName, command_states_directory, sendurl):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = threadName
        self.command_state_directory = command_states_directory
        self.sendurl = sendurl
    def run(self):
        print "Starting " + self.name
        global nthreadCounter
        global lstThreads
        # A loop that runs over all the json backup files and send it
        for currentJsonFile in glob.glob(PATH.join(self.command_state_directory, '*.json')):
            
            try:
                with open(currentJsonFile, 'r') as fsStream:
                    lstDataJson = json.load(fsStream)
            except ValueError:
                AnalocUtils.printDebug('Unable to decode json file:' + currentJsonFile + '. Deleting it.')
                AnalocUtils.deleteFile('RemoteControl-myThreadJsonCommandState', currentJsonFile)
            except BaseException as err:
                AnalocUtils.writeLog(logging.ERROR, 'RemoteControl-myThreadJsonCommandState', 'Line: ' + str(AnalocUtils.lineno()) + '. Unable to load the data from the JSON file: ' + currentJsonFile + '. Error: ' + str(err))
            
            # Create new threads
            threadCommanState = myThreadSetCommandState(nthreadCounter, "Thread-Json-Commands-id-" + str(nthreadCounter), lstDataJson, self.sendurl, False, '', currentJsonFile)
            nthreadCounter += 1
            
            # Add threads to thread list
            lstThreads.append(threadCommanState)
            
            # Starts the thread sender to send the data
            threadCommanState.start()

#=======================================================================================
# Method Description:
# Parameters:
# Return Value:
# Aditional Info:
#=======================================================================================
def setCommandState(ident_key, command_id, command_state, sendStatesUrl, commands_state_backup_directory_path, command_output = ''):
    global nthreadCounter
    global lstThreads
    
    lstData = []
    lstData.append({"ident_key" : ident_key, "id" : command_id, "state" : command_state, "output" : command_output})
    
    # Create new threads
    threadCommanState = myThreadSetCommandState(nthreadCounter, "Thread-Command-State-Sender-id-" + str(nthreadCounter), lstData, sendStatesUrl, True, commands_state_backup_directory_path)
    nthreadCounter += 1
    
    # Add threads to thread list
    lstThreads.append(threadCommanState)
    
    # Start new Threads
    threadCommanState.start()
    
#=======================================================================================
# Method Description:
# Parameters:
# Return Value:
# Aditional Info:
#=======================================================================================
def executeCommand(currentCommand, commandId, commandType, ident_key, sendStatesUrl, commands_state_backup_directory_path):
    # Checks for all the command types                                
    if (commandType == 'config_update'):
        if ((not currentCommand.has_key('key')) or (not currentCommand.has_key('value'))):
            doesWentWell = False
            errorMessage = 'The command: \'' + commandType + '\' must have the keys: \'key\' and \'value\''
        else:
            key = currentCommand['key']
            newValue = currentCommand['value']
            doesWentWell, errorMessage = AnalocCommands.updateConfigValue(key, newValue)
        
        # Checks if the command succeded
        if (doesWentWell):
            setCommandState(ident_key, commandId, STATE_EXECUTED, sendStatesUrl, commands_state_backup_directory_path)
        else:
            setCommandState(ident_key, commandId, STATE_FAILED, sendStatesUrl, commands_state_backup_directory_path, errorMessage)
    elif (commandType == 'config_add'):
        if ((not currentCommand.has_key('key')) or (not currentCommand.has_key('value'))):
            doesWentWell = False
            errorMessage = 'The command: \'' + commandType + '\' must have the keys: \'key\' and \'value\''
        else:
            key = currentCommand['key']
            newValue = currentCommand['value']
            doesWentWell, errorMessage = AnalocCommands.addNewConfigNode(key, newValue)
        
        # Checks if the command succeded
        if (doesWentWell):
            setCommandState(ident_key, commandId, STATE_EXECUTED, sendStatesUrl, commands_state_backup_directory_path)
        else:
            setCommandState(ident_key, commandId, STATE_FAILED, sendStatesUrl, commands_state_backup_directory_path, errorMessage)
    elif (commandType == 'config_remove'):
        if ((not currentCommand.has_key('key')) or (not currentCommand.has_key('value'))):
            doesWentWell = False
            errorMessage = 'The command: \'' + commandType + '\' must have the keys: \'key\' and \'value\''
        else:
            key = currentCommand['key']
            doesWentWell, errorMessage = AnalocCommands.removeConfigNode(key)
        
        # Checks if the command succeded
        if (doesWentWell):
            setCommandState(ident_key, commandId, STATE_EXECUTED, sendStatesUrl, commands_state_backup_directory_path)
        else:
            setCommandState(ident_key, commandId, STATE_FAILED, sendStatesUrl, commands_state_backup_directory_path, errorMessage)
    elif (commandType == 'command_line'):
        if ((not currentCommand.has_key('key')) or (not currentCommand.has_key('display_output'))):
            doesWentWell = False
            output = 'The command: \'' + commandType + '\' must have the keys: \'key\' and \'display_output\''
        else:
            command = currentCommand['key']
            show_output = False
            
            # Checks if we need to show the output
            if (str(currentCommand['display_output']) == "1"):
                show_output = True
            doesWentWell, output = AnalocCommands.runUnixCommand(command)
        
        # Checks if the command succeded
        if (doesWentWell):
            if (show_output):
                setCommandState(ident_key, commandId, STATE_EXECUTED, sendStatesUrl, commands_state_backup_directory_path, output)
            else:
                setCommandState(ident_key, commandId, STATE_EXECUTED, sendStatesUrl, commands_state_backup_directory_path)
        else:
            setCommandState(ident_key, commandId, STATE_FAILED, sendStatesUrl, commands_state_backup_directory_path, output)
    elif (commandType == 'get_current_version'):
        doesWentWell, output = AnalocCommands.getCurrentSoftwareVersion()
        
        # Checks if the command succeded
        if (doesWentWell):
            setCommandState(ident_key, commandId, STATE_EXECUTED, sendStatesUrl, commands_state_backup_directory_path, output)
        else:
            setCommandState(ident_key, commandId, STATE_FAILED, sendStatesUrl, commands_state_backup_directory_path, output)
    elif (commandType == 'update_code_version'):
        if (not currentCommand.has_key('key') or (not currentCommand.has_key('value'))):
            doesWentWell = False
            errorMessage = 'The command: \'' + commandType + '\' must have the keys: \'key\' and \'value\''
        else:
            urlToDownload = currentCommand['key']
            newVersionNumber = int(currentCommand['value'])
            doesWentWell, errorMessage = AnalocCommands.updateAnalocSystemScripts(urlToDownload, newVersionNumber)
            
        # Checks if the command succeded
        if (doesWentWell):
            setCommandState(ident_key, commandId, STATE_EXECUTED, sendStatesUrl, commands_state_backup_directory_path)
        else:
            setCommandState(ident_key, commandId, STATE_FAILED, sendStatesUrl, commands_state_backup_directory_path, errorMessage)
    else:
        output = 'There is no such command to execute: \'' + commandType + '\', for command id: ' + commandId
        setCommandState(ident_key, commandId, STATE_FAILED, sendStatesUrl, commands_state_backup_directory_path, output)

#=======================================================================================
# Method Description: The method gets the commands to execute from the server
# Parameters:   commands_state_backup_directory_path - The path of the directory to save the backup states to send to the server
#               sendStatesUrl - the url to send the states in the server  
# Return Value: None.
# Aditional Info: None.
#=======================================================================================
def getNewCommands(commands_state_backup_directory_path, sendStatesUrl):
    urlGetCommands = AnalocUtils.readConfigValue('server-url-get-commands')
    
    if (urlGetCommands != ''):
        # Gets the new commands to run
        dCommandsJson = AnalocSender.sendGetCommandsRequest(urlGetCommands)
    
        # Checks if there are commands to run
        if (dCommandsJson is not None):
            ident_key = AnalocUtils.readConfigValue('ident_key')
            
            # ident_key validation
            if (ident_key != dCommandsJson['ident_key']):
                AnalocUtils.writeLog(logging.CRITICAL, 'RemoteControl-getNewCommands', 'Line: ' + str(AnalocUtils.lineno()) + '. ident_key in sensor system is difrrent than ident_key given as a response to the get new commands from server.' + \
                                                                                        ' Maybe someone is trying to hack our system?')
            # Checks if the json has the commands key in it
            elif (not dCommandsJson.has_key('data')):
                AnalocUtils.writeLog(logging.CRITICAL, 'RemoteControl-getNewCommands', 'Line: ' + str(AnalocUtils.lineno()) + '. Commands data from server doesn\'t contains \'data\' key.')
            else:
                try:
                    lstCommands = dCommandsJson['data']
                except BaseException as err:
                    AnalocUtils.writeLog(logging.ERROR, 'RemoteControl-getNewCommands', 'Line: ' + str(AnalocUtils.lineno()) + '. Could not parse the json object for the commands to execute. Error: ' + str(err))
                else:
                    AnalocUtils.printDebug("Num of commands:" +  str(len(lstCommands)))
                    
                    # A loop that runs over all the commands
                    for currentCommand in lstCommands:
                        if (not currentCommand.has_key('command_type')):
                            AnalocUtils.writeLog(logging.ERROR, 'RemoteControl-getNewCommands', 'Line: ' + str(AnalocUtils.lineno()) + '. Commands data from server doesn\'t contains \'command_type\' key.')
                        elif (not currentCommand.has_key('command_id')):
                            AnalocUtils.writeLog(logging.ERROR, 'RemoteControl-getNewCommands', 'Line: ' + str(AnalocUtils.lineno()) + '. Commands data from server doesn\'t contains \'command_id\' key.')
                        else:
                            commandId = currentCommand['command_id']
                            commandType = currentCommand['command_type'].lower()
                            
                            # Execute the commands
                            executeCommand(currentCommand, commandId, commandType, ident_key, sendStatesUrl, commands_state_backup_directory_path)
                            
def main():
    global nthreadCounter
    global lstThreads
    
    commands_state_base_directory = AnalocUtils.readConfigValue('remote-commands-directory')
    commands_state_backup_directory_name = AnalocUtils.readConfigValue('remote-commands-states-backups-to-send')
    commands_state_backup_directory_path = PATH.join(commands_state_base_directory, commands_state_backup_directory_name)
    sendStatesUrl = AnalocUtils.readConfigValue('server-url-mark-command-state')
    
    # Checks if the path of the backup states exists.
    # If not, create it
    if not PATH.exists(commands_state_backup_directory_path):
        os.makedirs(commands_state_backup_directory_path)
        
    # Create new threads
    threadCommandsJsonSender = myThreadJsonCommandState(nthreadCounter, "Thread-Json-Commands-States-Sender-id-" + str(nthreadCounter), commands_state_backup_directory_path, sendStatesUrl)
    nthreadCounter += 1
    
    # Add threads to thread list
    lstThreads.append(threadCommandsJsonSender)
    
    # Starts the thread sender to send the data
    threadCommandsJsonSender.start()
    
    parser = argparse.ArgumentParser(description='Analoc remote control')
    parser.add_argument('-c','--command', help='The command to execute. Commands: get_commands', required=True)
    args = vars(parser.parse_args())

    # Checks if we got all the params needed
    if len(args) != 1:
        print 'incorrect number of arguments. expected 1, got:', str(len(args))
    elif args['command'] == "get_commands":
        getNewCommands(commands_state_backup_directory_path, sendStatesUrl)
    else:
        print 'No such command:', args['command']
    
    # Wait for all threads to complete
    for threadCurrent in lstThreads:
        threadCurrent.join()
    
    print "Exiting Main Thread of commands."

if __name__ == "__main__":
    main()